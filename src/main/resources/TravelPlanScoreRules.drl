import trippingo.optaplanner.resources.Day;
import trippingo.optaplanner.resources.PlanAttraction;
import trippingo.optaplanner.resources.TimeGrain;
import trippingo.optaplanner.resources.TripPlanner;
import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;
global HardSoftScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "withinOperatingHours"
	when
		$planAttraction : PlanAttraction ($StartingTimeGrain : startingTimeGrain.grainIndex < $OpeningTime : attraction.openingTimeGrains)
	then
		scoreHolder.addHardConstraintMatch(kcontext, $StartingTimeGrain - $OpeningTime );
		
end

rule "noDuplicateTimeslots"
	when
		$leftAssignment : PlanAttraction (startingTimeGrain != null)
		$rightAssignment : PlanAttraction (startingTimeGrain != null, attraction.id <  $leftAssignment.getAttraction().getId())
		
	then
        if ($leftAssignment.calculateOverlap($rightAssignment) != 0) {
            scoreHolder.addHardConstraintMatch(kcontext, -1);
        }	
		
		
end

rule "withinTravelHours"
	when 
		$planAttraction : PlanAttraction (startingTimeGrain!=null)
	
	then 
	if ($planAttraction.travelHoursPenaltyScore()!=0){
		scoreHolder.addHardConstraintMatch(kcontext, -$planAttraction.travelHoursPenaltyScore());
	}
	
end




rule "travelTimePenalty"
	when
	
	then (scoreHolder.addSoftConstraintMatch(kcontext, -$planAttraction.travelTimePenaltyScore());

	
end


// This rule can be a penalty or reward, reward > mean, penalty < mean
rule "attractionDurationBalancing"
	when
		$planAttraction : PlanAttraction ( )
	then 
		(scoreHolder.addSoftConstraintMatch(kcontext, $planAttraction.attractionDurationScore());
	
end
	


	
	

